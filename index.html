<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viscous Smoke Mixing</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            background-color: #111;
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="smokeCanvas"></canvas>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('smokeCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to match window size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Resize canvas when window size changes
            window.addEventListener('resize', function() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // Update container path when window is resized
                containerPath = generateContainerPath();
            });
            
            // Container configuration
            const containerConfig = {
                shape: 'custom',
                animationTime: 0,
                animationSpeed: 0.001,
                padding: 50,
                customPathFunction: createAnimatedContainer
            };
            
            // Animation state - simplified to avoid performance issues
            const animationConfig = {
                startTime: Date.now(),
                duration: 3000, // Shorter animation duration in ms
                progress: 0,
                complete: false
            };
            
            // Function to create container that animates from full screen to gaussian top with bottom at 1/3
            function createAnimatedContainer() {
                const path = new Path2D();
                const width = canvas.width;
                const height = canvas.height;
                
                // Calculate animation progress
                if (!animationConfig.complete) {
                    const elapsed = Date.now() - animationConfig.startTime;
                    animationConfig.progress = Math.min(elapsed / animationConfig.duration, 1);
                    
                    // Simple easing function (cubic ease out)
                    const easedProgress = 1 - Math.pow(1 - animationConfig.progress, 3);
                    
                    if (animationConfig.progress >= 1) {
                        animationConfig.complete = true;
                    }
                    
                    // Animate bottom border from bottom of screen to 1/3 from top
                    const startBottomY = height;
                    const endBottomY = height / 3;
                    const currentBottomY = startBottomY - (startBottomY - endBottomY) * easedProgress;
                    
                    // Start from bottom left corner
                    path.moveTo(0, currentBottomY);
                    
                    // Draw bottom line to bottom right
                    path.lineTo(width, currentBottomY);
                    
                    // Create the gaussian curve for the top boundary, with fewer points to improve performance
                    const gaussianPoints = 50; // Reduced number of points for better performance
                    const maxAmplitude = endBottomY * 0.8; // Final height of the gaussian curve
                    const currentAmplitude = maxAmplitude * easedProgress; // Amplitude increases with animation
                    const mean = width / 2; // Center of the curve
                    const stdDev = width / 6; // Width of the curve
                    
                    // Draw the gaussian curve from right to left
                    for (let i = gaussianPoints; i >= 0; i--) {
                        const x = width * (i / gaussianPoints);
                        // Gaussian function with increasing amplitude
                        const gaussianY = currentAmplitude * Math.exp(-Math.pow(x - mean, 2) / (2 * Math.pow(stdDev, 2)));
                        // Invert Y (lower Y is higher on canvas)
                        const y = currentBottomY - gaussianY;
                        
                        path.lineTo(x, y);
                    }
                } else {
                    // Animation complete, use final shape with vibration
                    
                    // Much faster vibration response with minimal smoothing
                    const targetVibration = (averageVolume / 10) * VIBRATION_INTENSITY; // More sensitive scaling
                    // Use almost no smoothing for quicker response
                    currentVibration = currentVibration * 0.2 + targetVibration * 0.8; // Heavy weighting toward new value
                    
                    // Bottom line at 1/3 from top
                    const bottomY = height / 3;
                    
                    // Start from bottom left corner
                    path.moveTo(0, bottomY);
                    
                    // Draw bottom line to bottom right
                    path.lineTo(width, bottomY);
                    
                    // Create the gaussian curve for the top boundary with more points for smoothness
                    const gaussianPoints = 100; // Increased for smoother curves
                    const baseAmplitude = bottomY * 0.8; // Base height of the gaussian curve
                    const mean = width / 2; // Center of the curve
                    const stdDev = width / 6; // Width of the curve
                    
                    // Use the dedicated vibrationTime for consistent vibration cycles
                    const vibrationPhase = vibrationTime * 2; // Phase for the vibration
                    
                    // Pre-calculate points to allow smoothing
                    const curvePoints = [];
                    
                    // First pass: calculate raw points
                    for (let i = gaussianPoints; i >= 0; i--) {
                        const x = width * (i / gaussianPoints);
                        
                        // Calculate position in the curve (0 at edges, 1 at center)
                        const position = Math.exp(-Math.pow(x - mean, 2) / (2 * Math.pow(stdDev, 2)));
                        
                        // Base Gaussian function
                        const baseGaussianY = baseAmplitude * position;
                        
                        // Create more responsive, higher frequency vibration
                        const vibrationFrequency = 3; // Higher frequency for quicker vibration 
                        const vibrationAmount = currentVibration * baseAmplitude * 0.7;
                        
                        // Add some randomness to the vibration for more natural response
                        const randomFactor = 1 + (Math.random() * 0.3 - 0.15);
                        const vibration = Math.sin(vibrationPhase + x * 0.015 * vibrationFrequency) * vibrationAmount * position * randomFactor;
                        
                        // Ensure vibration only goes upward (negative Y direction on canvas)
                        const gaussianY = baseGaussianY + Math.abs(vibration);
                        
                        // Invert Y (lower Y is higher on canvas)
                        const y = bottomY - gaussianY;
                        
                        curvePoints.push({ x, y });
                    }
                    
                    // Second pass: Apply Gaussian smoothing to points
                    const smoothedPoints = [];
                    const smoothingRadius = 3; // How many points to consider on each side
                    
                    for (let i = 0; i < curvePoints.length; i++) {
                        // Apply Gaussian smoothing to this point
                        let sum = 0;
                        let weightSum = 0;
                        
                        for (let j = Math.max(0, i - smoothingRadius); j <= Math.min(curvePoints.length - 1, i + smoothingRadius); j++) {
                            // Calculate Gaussian weight based on distance from center
                            const distance = Math.abs(i - j);
                            const weight = Math.exp(-(distance * distance) / (2 * smoothingRadius));
                            
                            sum += curvePoints[j].y * weight;
                            weightSum += weight;
                        }
                        
                        // Weighted average for this point
                        smoothedPoints.push({
                            x: curvePoints[i].x,
                            y: sum / weightSum
                        });
                    }
                    
                    // Draw the smoothed curve
                    for (let i = 0; i < smoothedPoints.length; i++) {
                        const point = smoothedPoints[i];
                        path.lineTo(point.x, point.y);
                    }
                }
                
                // Close the path
                path.closePath();
                return path;
            }
            
            // Example of a custom path function - can be replaced with any function that returns a Path2D
            function starShape() {
                const path = new Path2D();
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const outerRadius = Math.min(canvas.width, canvas.height) / 2.5;
                const innerRadius = outerRadius / 2;
                const spikes = 8;
                
                for (let i = 0; i < spikes * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI) / spikes;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        path.moveTo(x, y);
                    } else {
                        path.lineTo(x, y);
                    }
                }
                
                path.closePath();
                return path;
            }
            
            // Function to generate the container boundary path
            function generateContainerPath() {
                // This function returns a path that defines the container boundary
                // based on the current containerConfig settings
                
                // If a custom path function is set, use it
                if (containerConfig.shape === 'custom' && typeof containerConfig.customPathFunction === 'function') {
                    return containerConfig.customPathFunction();
                }
                
                // Create a new path
                const path = new Path2D();
                
                // Update animation time
                containerConfig.animationTime += containerConfig.animationSpeed;
                
                // Get dimensions based on canvas size and padding
                const padding = containerConfig.padding;
                const width = canvas.width - (padding * 2);
                const height = canvas.height - (padding * 2);
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                switch (containerConfig.shape) {
                    case 'circle':
                        // Create circular container
                        const radius = Math.min(width, height) / 2;
                        path.arc(centerX, centerY, radius, 0, Math.PI * 2);
                        break;
                    
                    case 'ellipse':
                        // Create elliptical container
                        path.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, Math.PI * 2);
                        break;
                    
                    case 'polygon':
                        // Create polygon container (hexagon)
                        const sides = 6;
                        const polyRadius = Math.min(width, height) / 2;
                        path.moveTo(centerX + polyRadius, centerY);
                        
                        for (let i = 1; i <= sides; i++) {
                            const angle = (i * 2 * Math.PI / sides);
                            path.lineTo(
                                centerX + polyRadius * Math.cos(angle),
                                centerY + polyRadius * Math.sin(angle)
                            );
                        }
                        break;
                    
                    case 'wave':
                        // Create a wavy container that changes over time
                        const wavePoints = 12;
                        const baseRadius = Math.min(width, height) / 2;
                        path.beginPath();
                        
                        for (let i = 0; i <= wavePoints; i++) {
                            const angle = (i * 2 * Math.PI / wavePoints);
                            const waveAmount = 50 * Math.sin(containerConfig.animationTime * 3 + i * 0.5);
                            const waveRadius = baseRadius + waveAmount;
                            
                            const x = centerX + waveRadius * Math.cos(angle);
                            const y = centerY + waveRadius * Math.sin(angle);
                            
                            if (i === 0) {
                                path.moveTo(x, y);
                            } else {
                                path.lineTo(x, y);
                            }
                        }
                        
                        break;
                    
                    case 'roundedRect':
                    default:
                        // Create a rounded rectangle as the container
                        const cornerRadius = 100; // Corner radius
                        
                        // Draw the rounded rectangle path
                        path.moveTo(padding + cornerRadius, padding);
                        path.lineTo(padding + width - cornerRadius, padding);
                        path.arcTo(padding + width, padding, padding + width, padding + cornerRadius, cornerRadius);
                        path.lineTo(padding + width, padding + height - cornerRadius);
                        path.arcTo(padding + width, padding + height, padding + width - cornerRadius, padding + height, cornerRadius);
                        path.lineTo(padding + cornerRadius, padding + height);
                        path.arcTo(padding, padding + height, padding, padding + height - cornerRadius, cornerRadius);
                        path.lineTo(padding, padding + cornerRadius);
                        path.arcTo(padding, padding, padding + cornerRadius, padding, cornerRadius);
                        break;
                }
                
                path.closePath();
                return path;
            }
            
            // Function to check if a point is inside the container path
            function isPointInContainer(x, y, path) {
                // Make sure we have a valid path before checking
                if (!path) return true; // Default to true if no path exists yet
                
                try {
                    return ctx.isPointInPath(path, x, y);
                } catch (e) {
                    // If there's an error (invalid path), return true as fallback
                    return true;
                }
            }
            
            // Post-processing to increase color intensity and reduce translucency
            function enhanceColors(ctx, width, height) {
                // Skip color processing when performance is critical
                const isQuiet = averageVolume < VOICE_THRESHOLD + 1;
                if (!isQuiet && Math.random() < 0.2) { // Only process occasionally when active (performance)
                    try {
                        // Get canvas image data
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const data = imageData.data;
                        
                        // Process every pixel (performance intensive)
                        for (let i = 0; i < data.length; i += 4) {
                            // Only process pixels that have some opacity
                            if (data[i+3] > 10) { 
                                // Boost saturation slightly
                                const r = data[i];
                                const g = data[i+1];
                                const b = data[i+2];
                                const max = Math.max(r, g, b);
                                
                                if (max > 0) {
                                    // Increase opacity for more solid appearance
                                    data[i+3] = Math.min(255, data[i+3] * 1.15);
                                    
                                    // Boost color slightly for more vibrant look
                                    data[i] = Math.min(255, r * 1.05);
                                    data[i+1] = Math.min(255, g * 1.05);
                                    data[i+2] = Math.min(255, b * 1.05);
                                }
                            }
                        }
                        
                        // Put the image data back
                        ctx.putImageData(imageData, 0, 0);
                    } catch (e) {
                        // Safely ignore any errors in color processing
                        console.log("Color processing error:", e);
                    }
                }
            }
            
            // Generate the initial container path
            let containerPath = createAnimatedContainer();
            
            // Smoke particles - optimized count for better performance
            const particles = [];
            const particleCount = Math.floor((window.innerWidth * window.innerHeight) / 3000); // Reduced particle count for better performance
            
            // Colors for the four smokes - even more vibrant for more solid appearance
            const color1 = [100, 210, 255];   // Blue - more vibrant
            const color2 = [255, 105, 70];    // Red-orange - more saturated
            const color3 = [140, 255, 100];   // Green - more intense
            const color4 = [255, 220, 50];    // Yellow-gold - more saturated
            
            // Animation timing - ensure consistent frame rate
            let lastTime = 0;
            const fps = 30; // Reduced FPS for better performance
            const interval = 1000 / fps;
            
            // Gaussian vibration parameters - increased intensity, reduced smoothing
            const VIBRATION_INTENSITY = 0.25; // Higher intensity for more pronounced effect
            const VIBRATION_SMOOTHING = 0.2; // Less smoothing for faster response
            let currentVibration = 0; // Current vibration offset
            let vibrationTime = 0; // Track time for consistent vibration cycles
            
            // Audio reactive variables
            let audioContext;
            let analyser;
            let dataArray;
            let averageVolume = 0;
            let micInitialized = false;
            
            // Reduced wind influence to support more random movement
            let windTime = 0;
            const windChangeRate = 0.0005; // Even slower change for better performance
            
            // Particle class
            class SmokeParticle {
                constructor(colorIndex) {
                    this.reset(colorIndex);
                }
                
                reset(colorIndex) {
                    // Store color index (0-3)
                    this.colorIndex = colorIndex;
                    
                    // Position particles within container bounds when possible
                    let validPosition = false;
                    let attempts = 0;
                    const maxAttempts = 10;
                    
                    // Try to find a position inside the container
                    while (!validPosition && attempts < maxAttempts) {
                        this.x = Math.random() * canvas.width;
                        this.y = Math.random() * canvas.height;
                        
                        // If we have a valid container path, check if point is inside
                        if (containerPath) {
                            validPosition = isPointInContainer(this.x, this.y, containerPath);
                        } else {
                            // If no container path yet, accept any position
                            validPosition = true;
                        }
                        
                        attempts++;
                    }
                    
                    // If still not valid after max attempts, position safely in middle area
                    if (!validPosition) {
                        this.x = canvas.width / 2 + (Math.random() - 0.5) * canvas.width / 4;
                        this.y = canvas.height / 4 + Math.random() * (canvas.height / 4);
                    }
                    
                    // Random initial direction instead of inward movement
                    this.initialDirection = Math.random() * Math.PI * 2; // Random angle in radians
                    
                    // Larger particles to ensure full screen coverage
                    this.radius = 50 + Math.random() * 70;
                    
                    // Initial velocities - based on random direction angle
                    const speed = 0.05 + Math.random() * 0.1; // Very slow base speed
                    this.vx = Math.cos(this.initialDirection) * speed; // X component of direction
                    this.vy = Math.sin(this.initialDirection) * speed; // Y component of direction

                    // Even higher opacity for nearly solid smoke
                    this.opacity = 0.6 + Math.random() * 0.2; // Dramatically increased initial opacity
                    this.maxOpacity = 0.8 + Math.random() * 0.15; // Nearly solid max opacity
                    this.growing = true;
                    
                    // Choose color based on colorIndex - with fallback for safety
                    let baseColor;
                    switch(this.colorIndex) {
                        case 0: baseColor = color1; break; // Blue
                        case 1: baseColor = color2; break; // Red-orange
                        case 2: baseColor = color3; break; // Green
                        case 3: baseColor = color4; break; // Yellow-gold
                        default: baseColor = color1; break; // Fallback to blue if index is invalid
                    }
                    
                    // Ensure baseColor is valid before spreading
                    this.color = baseColor ? [...baseColor] : [76, 175, 240]; // Default to blue if undefined
                    
                    // Life tracking
                    this.life = 0;
                    this.maxLife = 300 + Math.random() * 300;
                }
                
                update() {
                    this.life++;
                    
                    // Get volume boost but check if voice is active
                    let volumeBoost = Math.min(averageVolume / 15, 5.0);
                    
                    // If voice is below threshold (averageVolume close to 0.1),
                    // we should have minimal animation
                    const isQuiet = averageVolume < VOICE_THRESHOLD + 1;
                    
                    // Dynamic opacity based on voice activity - less transparency
                    let dynamicMaxOpacity;
                    if (isQuiet) {
                        // When quiet, maintain current opacity but don't grow
                        dynamicMaxOpacity = this.opacity;
                    } else {
                        // Normal behavior when voice is active - even higher max opacity
                        dynamicMaxOpacity = Math.min(this.maxOpacity * (1 + volumeBoost * 0.6), 0.98);
                    }
                    
                    // Movement multiplier based on voice
                    let volumeMultiplier = 0.01; // Near-zero when quiet
                    
                    if (!isQuiet) {
                        // Normal stepwise function when voice is active
                        if (volumeBoost > 3.0) volumeMultiplier = 6.0;      // Very loud - dramatic movement
                        else if (volumeBoost > 2.0) volumeMultiplier = 4.0; // Loud - strong movement
                        else if (volumeBoost > 1.0) volumeMultiplier = 2.5; // Medium - moderate movement
                        else volumeMultiplier = 1.0;                        // Soft voice - normal movement
                    }
                    
                    // Expansion rate is near zero when quiet
                    const baseExpansionRate = isQuiet ? 0.002 : 0.05;
                    const dynamicExpansionRate = (baseExpansionRate + Math.abs(this.vx + this.vy) * 0.1) * 
                                               (1 + volumeBoost * volumeMultiplier);

                    // Handle opacity
                    if (this.growing) {
                        this.opacity += 0.005 * (1 + volumeBoost * 0.2); // Faster growth with volume
                        if (this.opacity >= dynamicMaxOpacity) {
                            this.opacity = dynamicMaxOpacity;
                            this.growing = false;
                        }
                    } else if (this.life > this.maxLife * 0.7) {
                        this.opacity -= 0.002 * (1 + volumeBoost * 0.1); // Faster fade with volume
                    }
                    
                    // Wind strength near zero when quiet
                    const baseWindStrength = isQuiet ? 0.001 : 0.08;
                    
                    // Create abrupt changes in wind strength based on volume thresholds
                    let windVolumeMultiplier = isQuiet ? 0.01 : 1.0;
                    
                    if (!isQuiet) {
                        if (volumeBoost > 3.0) {
                            // Very loud sounds create sudden, dramatic movements
                            windVolumeMultiplier = 12.0;
                            // Add random direction changes for "excited" movement
                            if (Math.random() < 0.15) {
                                this.initialDirection = Math.random() * Math.PI * 2;
                            }
                        } else if (volumeBoost > 2.0) {
                            windVolumeMultiplier = 8.0;
                        } else if (volumeBoost > 1.0) {
                            windVolumeMultiplier = 5.0;
                        }
                    }
                    
                    const dynamicWindStrength = baseWindStrength * (1 + volumeBoost * windVolumeMultiplier);
                    const windDirection = Math.sin(windTime + this.x * 0.005) * dynamicWindStrength;
                    const verticalWind = Math.cos(windTime * 0.4 + this.y * 0.004) * dynamicWindStrength * 0.5;
                    
                    // Add some drift based on position to create mixing
                    const centerInfluence = 0.001;
                    const centerX = canvas.width / 2;
                    
                    // Remove center pull for truly random movement
                    // No center influence code here
                    
                    // Slight influence from wind but primarily random direction
                    this.vx += windDirection * 0.1; // Reduced wind effect
                    this.vy += verticalWind * 0.1;
                    
                    // Small random movement variation - drastically reduced when quiet
                    if (isQuiet) {
                        // Near-zero random variation when quiet
                        this.vx += (Math.random() - 0.5) * 0.0005;
                        this.vy += (Math.random() - 0.5) * 0.0005;
                    } else {
                        // Increased random variation when voice is active for more responsiveness
                        this.vx += (Math.random() - 0.5) * 0.05;
                        this.vy += (Math.random() - 0.5) * 0.05;
                    }
                    
                    // Occasionally change direction slightly for more random movement
                    if (Math.random() < 0.01) { // 1% chance each frame
                        const angleChange = (Math.random() - 0.5) * 0.2; // Small angle change
                        const currentAngle = Math.atan2(this.vy, this.vx);
                        const newAngle = currentAngle + angleChange;
                        
                        // Calculate new velocity components while maintaining speed
                        const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                        this.vx = Math.cos(newAngle) * currentSpeed;
                        this.vy = Math.sin(newAngle) * currentSpeed;
                    }
                    
                    // Apply viscosity - stronger when quiet to quickly stop movement
                    if (isQuiet) {
                        this.vx *= 0.9; // Much stronger damping when quiet
                        this.vy *= 0.9;
                    } else {
                        this.vx *= 0.98;
                        this.vy *= 0.98;
                    }
                    
                    // Apply velocity only if not in quiet mode
                    if (!isQuiet) {
                        this.x += this.vx;
                        this.y += this.vy;
                    } else {
                        // Extremely minimal movement when quiet for slight "floating" appearance
                        this.x += this.vx * 0.01;
                        this.y += this.vy * 0.01;
                    }
                    
                    // Apply dynamic expansion rate
                    this.radius += dynamicExpansionRate;
                    
                    // Handle collisions with other particles (viscous mixing) - faster mixing with volume
                    for (let other of particles) {
                        if (other !== this) {
                            const dx = other.x - this.x;
                            const dy = other.y - this.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const minDist = this.radius + other.radius;
                            
                            // If particles are close enough to interact
                            if (distance < minDist * 0.7) {
                                // Color mixing when particles of different colors meet
                                if (this.colorIndex !== other.colorIndex) {
                                    // Determine the other particle's color with fallback
                                    let otherColor;
                                    switch(other.colorIndex) {
                                        case 0: otherColor = color1; break; // Blue
                                        case 1: otherColor = color2; break; // Red-orange
                                        case 2: otherColor = color3; break; // Green
                                        case 3: otherColor = color4; break; // Yellow-gold
                                        default: otherColor = null; break;  // Invalid index
                                    }
                                    
                                    // Only blend if both colors are valid
                                    if (otherColor && this.color) {
                                        // Blend colors based on voice activity
                                        const isQuiet = averageVolume < VOICE_THRESHOLD + 1;
                                        const blendRate = isQuiet ? 0.001 : 0.02 * (1 + volumeBoost * 5.0);
                                        
                                        if (isQuiet) {
                                            // Minimal color blending when quiet
                                            for (let i = 0; i < 3; i++) {
                                                this.color[i] = this.color[i] * 0.9995 + otherColor[i] * 0.0005;
                                            }
                                        } else if (volumeBoost > 2.5) {
                                            // Dramatic color shift - more sudden changes
                                            for (let i = 0; i < 3; i++) {
                                                // More weighted toward the other color for dramatic shifts
                                                this.color[i] = this.color[i] * (1 - blendRate * 1.5) + otherColor[i] * blendRate * 1.5;
                                            }
                                        } else {
                                            // Normal blending
                                            for (let i = 0; i < 3; i++) {
                                                this.color[i] = this.color[i] * (1 - blendRate) + otherColor[i] * blendRate;
                                            }
                                        }
                                    }
                                }
                                
                                // Repulsion (viscous push) - stronger push with volume? (optional)
                                let repulsion = 0.02; // Original repulsion force
                                // New colors have slightly different repulsion force
                                if (this.colorIndex >= 2 || other.colorIndex >= 2) {
                                    repulsion = 0.018; // Original difference
                                }
                                const nx = dx / distance;
                                const ny = dy / distance;
                                this.vx -= nx * repulsion;
                                this.vy -= ny * repulsion;
                            }
                        }
                    }
                    
                    // Reset when faded or at end of life - potentially reset faster with volume?
                    const dynamicMaxLife = this.maxLife * (1 - volumeBoost * 0.1); // Shorter life with high volume
                    if (this.opacity <= 0 || this.life >= dynamicMaxLife) {
                        // Keep original color index when resetting for color continuity
                        const originalColorIndex = this.colorIndex;
                        this.reset(originalColorIndex);
                        
                        // When resetting during active voice, ensure high opacity immediately
                        if (!isQuiet && averageVolume > VOICE_THRESHOLD + 10) {
                            this.opacity = Math.min(0.9, this.maxOpacity * 0.9); // Start with higher opacity during active speech
                            this.growing = false; // Skip growth phase during active speech
                        }
                    } else {
                        // Calculate next position
                        const nextX = this.x + this.vx;
                        const nextY = this.y + this.vy;
                        
                        // Check if next position is within container
                        if (!isPointInContainer(nextX, nextY, containerPath)) {
                            // Handle collision with container boundary
                            // This is a simple reflection model; can be made more sophisticated
                            
                            // Sample points around the particle to estimate the normal of the boundary
                            const samples = 8;
                            let normalX = 0;
                            let normalY = 0;
                            
                            for (let i = 0; i < samples; i++) {
                                const angle = (i / samples) * Math.PI * 2;
                                const sampleX = this.x + Math.cos(angle) * (this.radius * 1.2);
                                const sampleY = this.y + Math.sin(angle) * (this.radius * 1.2);
                                
                                if (!isPointInContainer(sampleX, sampleY, containerPath)) {
                                    normalX += this.x - sampleX;
                                    normalY += this.y - sampleY;
                                }
                            }
                            
                            // Normalize the normal vector
                            const normalLength = Math.sqrt(normalX * normalX + normalY * normalY);
                            if (normalLength > 0) {
                                normalX /= normalLength;
                                normalY /= normalLength;
                                
                                // Reflect velocity vector using the normal
                                const dot = 2 * (this.vx * normalX + this.vy * normalY);
                                this.vx -= dot * normalX;
                                this.vy -= dot * normalY;
                                
                                // Apply damping
                                this.vx *= 0.8;
                                this.vy *= 0.8;
                                
                                // Move particle slightly inward to ensure it stays in bounds
                                const buffer = 2;
                                this.x += normalX * buffer;
                                this.y += normalY * buffer;
                            } else {
                                // Fallback if normal estimation fails: bounce in random direction
                                const randomAngle = Math.random() * Math.PI * 2;
                                this.vx = Math.cos(randomAngle) * Math.sqrt(this.vx * this.vx + this.vy * this.vy) * 0.8;
                                this.vy = Math.sin(randomAngle) * Math.sqrt(this.vx * this.vx + this.vy * this.vy) * 0.8;
                            }
                        } else {
                            // Apply velocity if inside container
                            this.x = nextX;
                            this.y = nextY;
                        }
                    }
                }
                
                draw() {
                    if (this.opacity <= 0) return;
                    
                    // Save current context state
                    ctx.save();
                    
                    // Clip to container path so smoke isn't rendered outside the boundary
                    // Only clip if we have a valid path
                    if (containerPath) {
                        ctx.clip(containerPath);
                    }
                    
                    // Create gradient for smooth edges
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.radius
                    );
                    
                    const [r, g, b] = this.color;
                    // Almost solid colors with minimal transparency in gradient
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${Math.min(1.0, this.opacity * 1.7)})`); // Nearly solid center
                    gradient.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, ${Math.min(0.95, this.opacity * 1.5)})`); // Very opaque inner area
                    gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, ${this.opacity * 0.8})`); // Less transparent middle
                    gradient.addColorStop(0.85, `rgba(${r}, ${g}, ${b}, ${this.opacity * 0.4})`); // More gradual fade at edge
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Restore context state
                    ctx.restore();
                }
            }
            
            // Initialize particles with performance optimizations
            function init() {
                // Start with fewer particles during animation
                const initialParticleCount = Math.floor(particleCount * 0.5);
                
                for (let i = 0; i < initialParticleCount; i++) {
                    // Create particles of all four colors, evenly distributed
                    const particle = new SmokeParticle(i % 4);
                    
                    // Ensure particles start inside the container
                    let attempts = 0;
                    const maxAttempts = 5;
                    while (!isPointInContainer(particle.x, particle.y, containerPath) && attempts < maxAttempts) {
                        particle.x = Math.random() * canvas.width;
                        particle.y = Math.random() * canvas.height;
                        attempts++;
                    }
                    
                    particles.push(particle);
                }
                
                // Schedule adding the rest of the particles after animation completes
                setTimeout(() => {
                    const remainingCount = particleCount - initialParticleCount;
                    for (let i = 0; i < remainingCount; i++) {
                        const particle = new SmokeParticle(i % 4);
                        
                        // Ensure particles start inside the container
                        let attempts = 0;
                        const maxAttempts = 5;
                        while (!isPointInContainer(particle.x, particle.y, containerPath) && attempts < maxAttempts) {
                            particle.x = Math.random() * canvas.width;
                            particle.y = Math.random() * canvas.height;
                            attempts++;
                        }
                        
                        particles.push(particle);
                    }
                }, animationConfig.duration + 500);
            }

            // Setup Web Audio API for microphone input with better speech response
            async function setupAudio() {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    console.error('getUserMedia not supported on your browser!');
                    alert('Microphone access is not supported by your browser.');
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();

                    // Configure analyser for better speech response
                    analyser.fftSize = 512; // Increased for better frequency resolution
                    analyser.smoothingTimeConstant = 0.3; // Lower value for faster response to changes
                    
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);

                    // Create a filter to emphasize speech frequencies
                    const filter = audioContext.createBiquadFilter();
                    filter.type = "bandpass";
                    filter.frequency.value = 1000; // Center on typical speech frequencies
                    filter.Q.value = 0.5; // Wider bandwidth to catch all speech

                    // Connect microphone stream to filter then analyser
                    const source = audioContext.createMediaStreamSource(stream);
                    source.connect(filter);
                    filter.connect(analyser);
                    // We don't need to connect to destination unless we want to hear the mic

                    micInitialized = true;
                    console.log("Microphone access granted and audio analyser set up.");

                    // Update instructions
                    instructions.innerHTML += '<br>â€¢ Audio Reactive! (Speak to intensify)';

                } catch (err) {
                    console.error(`Error accessing microphone: ${err}`);
                    alert(`Could not access microphone: ${err.message}. Audio reactivity disabled.`);
                }
            }

            // Function to get average volume from analyser
            // Voice activity detection constants
            const VOICE_THRESHOLD = 8; // Lower threshold to detect speech earlier
            const MIN_VOICE_DURATION = 150; // Shorter duration for faster detection
            let lastVoiceTime = 0;
            let isVoiceActive = false;
            
            function getAverageVolume() {
                if (!micInitialized || !analyser || !dataArray) return 0;

                analyser.getByteFrequencyData(dataArray); // Use frequency data as proxy for volume

                // Focus more on higher frequencies where speech is more prominent
                let sum = 0;
                let weightedCount = 0;
                
                for (let i = 0; i < dataArray.length; i++) {
                    // Apply higher weight to speech frequencies (typically 85-255Hz and 2-4kHz)
                    let weight = 1.0;
                    
                    // Weight middle frequencies higher for better speech response
                    // This is a simplified approach - real implementation would use proper frequency bins
                    if (i > dataArray.length * 0.2 && i < dataArray.length * 0.7) {
                        weight = 2.0; // Double the importance of speech frequency ranges
                    }
                    
                    sum += dataArray[i] * weight;
                    weightedCount += weight;
                }
                
                // Calculate raw volume
                const newVolume = sum / weightedCount;
                
                // Voice activity detection
                const now = Date.now();
                if (newVolume > VOICE_THRESHOLD) {
                    lastVoiceTime = now;
                    isVoiceActive = true;
                } else if (now - lastVoiceTime > MIN_VOICE_DURATION) {
                    isVoiceActive = false;
                }
                
                // If voice is not active, return near-zero value to freeze animation
                if (!isVoiceActive) {
                    return 0.1; // Just above zero to maintain minimal movement
                }
                
                // If the new volume is significantly higher, respond immediately for abrupt changes
                // Otherwise, use a bit of smoothing
                if (newVolume > averageVolume * 1.5) {
                    return newVolume; // Immediate response to large increases
                } else {
                    return averageVolume * 0.7 + newVolume * 0.3; // Some smoothing for decreases
                }
            }
            
            // Global variable for pulse effect
            let pulseEffect = {
                active: false,
                intensity: 0,
                decay: 0.1
            };

            // State tracking for clearing logic
            let wasPreviouslyQuiet = true; 
            
            // Animation loop
            function animate(currentTime) {
                requestAnimationFrame(animate);
                
                // Control frame rate
                const elapsed = currentTime - lastTime;
                if (elapsed < interval) return;
                lastTime = currentTime - (elapsed % interval);

                // Get audio volume
                const prevVolume = averageVolume;
                averageVolume = getAverageVolume();
                
                // Update wind time based on voice activity - almost freeze when quiet
                const isCurrentlyQuiet = averageVolume < VOICE_THRESHOLD + 1; // Renamed for clarity
                if (isCurrentlyQuiet) {
                    windTime += windChangeRate * 0.01; // Extremely slow wind change when quiet
                    vibrationTime += 0.008; // Slightly faster minimal vibration even when quiet
                } else {
                    windTime += windChangeRate * 0.6;  // Normal wind change when voice active
                    vibrationTime += 0.08 * (1 + averageVolume / 30); // Even faster vibration time advancement
                }
                
                // Detect significant volume increases for pulse effect
                if (averageVolume > prevVolume * 1.7 && averageVolume > 20) {
                    // Trigger pulse effect on sudden loud sounds
                    pulseEffect.active = true;
                    pulseEffect.intensity = Math.min(1.0, averageVolume / 100); // Cap at 1.0
                }
                
                // Handle pulse effect decay
                if (pulseEffect.active) {
                    pulseEffect.intensity -= pulseEffect.decay;
                    if (pulseEffect.intensity <= 0) {
                        pulseEffect.active = false;
                        pulseEffect.intensity = 0;
                    }
                }
                
                // Detect transition from active to quiet state
                const didTransitionToQuiet = !wasPreviouslyQuiet && isCurrentlyQuiet;

                // During animation, we might need to clear particles that get stuck outside
                // the container as it shrinks
                if (!animationConfig.complete && animationConfig.progress > 0.1) {
                    // Every few frames, check if particles are inside the container
                    if (Math.random() < 0.1) { // 10% chance each frame
                        particles.forEach(particle => {
                            if (!isPointInContainer(particle.x, particle.y, containerPath)) {
                                particle.opacity = Math.max(0, particle.opacity - 0.05);
                            }
                        });
                    }
                }
                
                // Reduced wind time rate for slower changes
                windTime += windChangeRate * 0.6;
                
                // Clear differently based on animation state
                if (!animationConfig.complete) {
                    // During animation, clear more aggressively to prevent halos
                    ctx.fillStyle = 'rgba(17, 17, 17, 0.3)'; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Always update container path during animation
                    containerPath = createAnimatedContainer();
                } else {
                // After animation completes, regenerate path every frame for vibration
                    containerPath = createAnimatedContainer();
                    
                    // --- Clearing Logic ---
                    if (didTransitionToQuiet) {
                        // Perform multiple full clears when transitioning to quiet to aggressively remove halos
                        // First immediate clear
                        ctx.fillStyle = 'rgb(17, 17, 17)'; // Opaque background color
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Set a flag to continue clearing for a few frames
                        if (!window.forceClearFrames) {
                            window.forceClearFrames = 5; // Clear aggressively for the next 5 frames
                        }
                    } else if (isCurrentlyQuiet) {
                        // When quiet, aggressively clear until ghost images are gone
                        if (window.forceClearFrames > 0) {
                            // Aggressive clearing during the force clear period
                            ctx.fillStyle = 'rgb(17, 17, 17)'; // Full opaque clear
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            window.forceClearFrames--;
                        } else if (Math.random() < 0.2) { // 20% chance each frame to do a full clear - much more frequent
                            ctx.fillStyle = 'rgb(17, 17, 17)'; // Full clear
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                        } else if (pulseEffect.active) {
                            // Apply pulse effect when active
                            const baseColor = 17;
                            const pulseColor = Math.min(50, baseColor + Math.floor(pulseEffect.intensity * 40));
                            ctx.fillStyle = `rgba(${pulseColor}, ${pulseColor}, ${pulseColor}, 0.15)`;
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                        } else {
                            // Standard quiet state with higher clear amount
                            const clearAmount = 0.4; // Significantly increased for faster fading
                            ctx.fillStyle = `rgba(17, 17, 17, ${clearAmount})`;
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                        }
                    } else { // Not quiet (active speech)
                        // Reset force clear frames counter when active
                        window.forceClearFrames = 0;
                        
                        // Apply pulse effect if active
                        if (pulseEffect.active) {
                            const baseColor = 17;
                            const pulseColor = Math.min(50, baseColor + Math.floor(pulseEffect.intensity * 40));
                            // Clear aggressively for active state
                            const clearAmount = 0.9;
                            ctx.fillStyle = `rgba(17, 17, 17, ${clearAmount})`;
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // Draw pulse over the aggressive clear
                            ctx.fillStyle = `rgba(${pulseColor}, ${pulseColor}, ${pulseColor}, 0.1)`;
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                        } else {
                            // Active state without pulse: clear aggressively
                            const clearAmount = 0.9;
                            ctx.fillStyle = `rgba(17, 17, 17, ${clearAmount})`;
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                        }
                    }
                 }
                
                // Draw container boundary (optional, can be subtle)
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.2)'; // Make it more subtle
                ctx.lineWidth = 1; // Thinner line
                ctx.stroke(containerPath);
                
                // Update and draw particles - with performance optimizations
                for (let i = 0; i < particles.length; i++) {
                    const particle = particles[i];
                    
                    // During animation, skip updating some particles to improve performance
                    if (!animationConfig.complete && i % 2 === 0) {
                        particle.draw(); // Still draw but don't update
                    } else {
                        particle.update();
                        particle.draw();
                    }
                }
                
                // Apply color enhancement for less translucency
                enhanceColors(ctx, canvas.width, canvas.height);

                // Update quiet state tracker for the next frame
                wasPreviouslyQuiet = isCurrentlyQuiet;
            }
            
            // Create a public API for controlling the smoke container
            window.smokeContainer = {
                // Get the current control points
                getControlPoints: function() {
                    return JSON.parse(JSON.stringify(controlPoints)); // Return a deep copy
                },
                
                // Set control points programmatically
                setControlPoints: function(points) {
                    if (Array.isArray(points) && points.length >= 3) {
                        controlPoints.length = 0; // Clear existing points
                        
                        // Add each point
                        points.forEach(point => {
                            if (typeof point.x === 'number' && typeof point.y === 'number') {
                                controlPoints.push({
                                    x: point.x,
                                    y: point.y,
                                    isDragging: false
                                });
                            }
                        });
                        
                        containerPath = generatePathFromControlPoints();
                        return true;
                    }
                    return false;
                },
                
                // Add a control point at specific index
                addControlPoint: function(x, y, index = -1) {
                    const newPoint = { x, y, isDragging: false };
                    
                    if (index >= 0 && index <= controlPoints.length) {
                        controlPoints.splice(index, 0, newPoint);
                    } else {
                        controlPoints.push(newPoint);
                    }
                    
                    containerPath = generatePathFromControlPoints();
                    return controlPoints.length - 1; // Return index of the new point
                },
                
                // Remove a control point
                removeControlPoint: function(index) {
                    if (index >= 0 && index < controlPoints.length && controlPoints.length > 3) {
                        controlPoints.splice(index, 1);
                        containerPath = generatePathFromControlPoints();
                        return true;
                    }
                    return false;
                },
                
                // Reset to default circular shape
                resetToCircle: function(numPoints = 8) {
                    controlPoints.length = 0;
                    
                    for (let i = 0; i < numPoints; i++) {
                        const angle = (i / numPoints) * Math.PI * 2;
                        const radius = Math.min(canvas.width, canvas.height) / 3;
                        const x = canvas.width / 2 + Math.cos(angle) * radius;
                        const y = canvas.height / 2 + Math.sin(angle) * radius;
                        controlPoints.push({ x, y, isDragging: false });
                    }
                    
                    containerPath = generatePathFromControlPoints();
                    return true;
                },
                
                // Set a custom path directly using Path2D
                setCustomPath: function(path) {
                    if (path instanceof Path2D) {
                        containerPath = path;
                        return true;
                    }
                    return false;
                },
                
                // Get the current container path
                getContainerPath: function() {
                    return containerPath;
                },
                
                // Check if a point is inside the container
                isPointInContainer: function(x, y) {
                    return isPointInContainer(x, y, containerPath);
                },
                
                // Show or hide control points
                showControlPoints: function(show = true) {
                    showControlPoints = show;
                }
            };
            
            // Start animation and audio setup
            setupAudio(); // Request mic access
            init();
            animate(0);
            
            // Define control points for the boundary
            const controlPoints = [];
            const numInitialPoints = 8;
            
            // Init control points in a circle
            for (let i = 0; i < numInitialPoints; i++) {
                const angle = (i / numInitialPoints) * Math.PI * 2;
                const radius = Math.min(canvas.width, canvas.height) / 3;
                const x = canvas.width / 2 + Math.cos(angle) * radius;
                const y = canvas.height / 2 + Math.sin(angle) * radius;
                controlPoints.push({ x, y, isDragging: false });
            }
            
            // Container path configuration
            const pathConfig = {
                curveType: 'catmull-rom', // Options: 'bezier', 'catmull-rom', 'cardinal'
                segments: 10 // Number of segments for Catmull-Rom
            };
            
            // Function to generate container path from control points
            function generatePathFromControlPoints() {
                const path = new Path2D();
                
                if (controlPoints.length < 3) return path;
                
                // Get current curve type from config
                const curveType = pathConfig.curveType;
                
                switch (curveType) {
                    case 'bezier':
                        // Simple cubic Bezier curves
                        path.moveTo(controlPoints[0].x, controlPoints[0].y);
                        
                        // Create a smooth curve through the points
                        for (let i = 0; i < controlPoints.length; i++) {
                            const current = controlPoints[i];
                            const next = controlPoints[(i + 1) % controlPoints.length];
                            const prev = controlPoints[(i - 1 + controlPoints.length) % controlPoints.length];
                            
                            // Calculate control points for curve
                            const tension = 0.2; // How smooth the curve is (0-1)
                            
                            // Control point before current point
                            const cp1x = current.x - (next.x - prev.x) * tension;
                            const cp1y = current.y - (next.y - prev.y) * tension;
                            
                            // Control point after current point
                            const cp2x = next.x - (controlPoints[(i + 2) % controlPoints.length].x - current.x) * tension;
                            const cp2y = next.y - (controlPoints[(i + 2) % controlPoints.length].y - current.y) * tension;
                            
                            // Draw the bezier curve to the next point
                            path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y);
                        }
                        break;
                        
                    case 'cardinal':
                        // Cardinal spline (smoother than Bezier)
                        path.moveTo(controlPoints[0].x, controlPoints[0].y);
                        
                        const cardinalTension = 0.5; // 0 = linear, 1 = very curvy
                        
                        for (let i = 0; i < controlPoints.length; i++) {
                            const p0 = controlPoints[(i - 1 + controlPoints.length) % controlPoints.length];
                            const p1 = controlPoints[i];
                            const p2 = controlPoints[(i + 1) % controlPoints.length];
                            const p3 = controlPoints[(i + 2) % controlPoints.length];
                            
                            // Calculate cardinal spline control points
                            const t = cardinalTension;
                            const s = (1 - t) / 2;
                            
                            const cp1x = p1.x + s * (p2.x - p0.x);
                            const cp1y = p1.y + s * (p2.y - p0.y);
                            const cp2x = p2.x - s * (p3.x - p1.x);
                            const cp2y = p2.y - s * (p3.y - p1.y);
                            
                            path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                        }
                        break;
                        
                    case 'catmull-rom':
                    default:
                        // Catmull-Rom spline (passes through all points)
                        const points = [...controlPoints];
                        const segments = 10; // Number of segments between each pair of points
                        
                        // Generate points along the spline
                        const curvePoints = [];
                        
                        for (let i = 0; i < points.length; i++) {
                            const p0 = points[(i - 1 + points.length) % points.length];
                            const p1 = points[i];
                            const p2 = points[(i + 1) % points.length];
                            const p3 = points[(i + 2) % points.length];
                            
                            // Add segments for the current point pair (p1 to p2)
                            for (let t = 0; t < (i === points.length - 1 ? segments + 1 : segments); t++) {
                                const t1 = t / segments;
                                
                                // Catmull-Rom interpolation formula
                                const t2 = t1 * t1;
                                const t3 = t2 * t1;
                                
                                // Coefficients for Catmull-Rom interpolation
                                const h1 = -0.5 * t3 + t2 - 0.5 * t1;
                                const h2 = 1.5 * t3 - 2.5 * t2 + 1;
                                const h3 = -1.5 * t3 + 2 * t2 + 0.5 * t1;
                                const h4 = 0.5 * t3 - 0.5 * t2;
                                
                                // Calculate point position
                                const x = h1 * p0.x + h2 * p1.x + h3 * p2.x + h4 * p3.x;
                                const y = h1 * p0.y + h2 * p1.y + h3 * p2.y + h4 * p3.y;
                                
                                curvePoints.push({ x, y });
                            }
                        }
                        
                        // Use the curve points to draw the path
                        if (curvePoints.length > 0) {
                            path.moveTo(curvePoints[0].x, curvePoints[0].y);
                            
                            for (let i = 1; i < curvePoints.length; i++) {
                                path.lineTo(curvePoints[i].x, curvePoints[i].y);
                            }
                        }
                        break;
                }
                
                path.closePath();
                return path;
            }
            
            // Update the custom path function to use control points
            containerConfig.customPathFunction = generatePathFromControlPoints;
            containerConfig.shape = 'custom';
            
            // Control if control points should be visible
            let showControlPoints = true;
            
            // Draw control points
            function drawControlPoints() {
                if (!showControlPoints) return;
                
                ctx.save();
                
                // Draw lines between points
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.beginPath();
                for (let i = 0; i < controlPoints.length; i++) {
                    const point = controlPoints[i];
                    const nextPoint = controlPoints[(i + 1) % controlPoints.length];
                    
                    ctx.moveTo(point.x, point.y);
                    ctx.lineTo(nextPoint.x, nextPoint.y);
                }
                ctx.stroke();
                
                // Draw points
                for (let i = 0; i < controlPoints.length; i++) {
                    const point = controlPoints[i];
                    
                    // Draw control point
                    ctx.fillStyle = point.isDragging ? 'rgba(255, 100, 100, 0.8)' : 'rgba(200, 200, 200, 0.8)';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw point number
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(i + 1, point.x, point.y);
                }
                
                ctx.restore();
            }
            
            // Handle mouse interaction for disturbing the smoke
            let isMousePressed = false;
            
            // Distance from point to line segment
            function distanceToSegment(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) {
                    param = dot / lenSq;
                }
                
                let xx, yy;
                
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                
                return {
                    distance: Math.sqrt(dx * dx + dy * dy),
                    param: param,
                    x: xx,
                    y: yy
                };
            }
            
            // Helper to find nearest segment to a point
            function findNearestSegment(x, y) {
                let minDistance = Infinity;
                let segmentIndex = -1;
                let insertPosition = -1;
                
                for (let i = 0; i < controlPoints.length; i++) {
                    const p1 = controlPoints[i];
                    const p2 = controlPoints[(i + 1) % controlPoints.length];
                    
                    const result = distanceToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    
                    if (result.distance < minDistance) {
                        minDistance = result.distance;
                        segmentIndex = i;
                        insertPosition = (i + 1) % controlPoints.length;
                    }
                }
                
                return { segmentIndex, minDistance, insertPosition };
            }
            
            // Mouse event handlers
            canvas.addEventListener('mousedown', function(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                isMousePressed = true;
                
                // Create a disturbance if inside the container
                if (isPointInContainer(mouseX, mouseY, containerPath)) {
                    particles.forEach(particle => {
                        const dx = particle.x - mouseX;
                        const dy = particle.y - mouseY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const maxDistance = 200;
                        
                        if (distance < maxDistance) {
                            const force = 2 * (1 - distance / maxDistance);
                            const angle = Math.atan2(dy, dx);
                            particle.vx += Math.cos(angle) * force;
                            particle.vy += Math.sin(angle) * force;
                        }
                    });
                }
            });
            
            canvas.addEventListener('mousemove', function(e) {
                if (!isMousePressed) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Continue disturbance if mouse is pressed and inside container
                if (isPointInContainer(mouseX, mouseY, containerPath)) {
                    particles.forEach(particle => {
                        const dx = particle.x - mouseX;
                        const dy = particle.y - mouseY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const maxDistance = 150;
                        
                        if (distance < maxDistance) {
                            const force = 1.5 * (1 - distance / maxDistance);
                            const angle = Math.atan2(dy, dx);
                            particle.vx += Math.cos(angle) * force;
                            particle.vy += Math.sin(angle) * force;
                        }
                    });
                }
            });
            
            canvas.addEventListener('mouseup', function() {
                isMousePressed = false;
            });
            
            // Handle window resize - ensure path is regenerated correctly
            window.addEventListener('resize', function() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Regenerate path immediately after resize
                containerPath = createAnimatedContainer(); 
                
                // If animation was complete, keep it complete
                if (animationConfig.complete) {
                    // No need to restart animation, keep it in final state
                } else {
                    // Keep current progress for smoother transition during resize
                }
            });
            
            // Instructions overlay
            const instructions = document.createElement('div');
            instructions.style.position = 'absolute';
            instructions.style.bottom = '10px';
            instructions.style.left = '10px';
            instructions.style.padding = '10px';
            instructions.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            instructions.style.borderRadius = '5px';
            instructions.style.color = '#fff';
            instructions.style.fontFamily = 'Arial, sans-serif';
            instructions.style.zIndex = '1000';
            instructions.style.fontSize = '12px';
                instructions.style.lineHeight = '1.4';
                instructions.style.maxWidth = '300px';
                
                instructions.innerHTML = `
                <strong>Smoke Container:</strong><br>
                â€¢ Gaussian top vibrates with speech<br>
                â€¢ Final border at 1/3 from top<br>
                â€¢ Click inside to disturb smoke<br>
                â€¢ <b>Speak into microphone to activate!</b><br>
                â€¢ Animation freezes when quiet<br>
                â€¢ Louder speech = more dramatic movement & vibration
            `;
            
            document.getElementById('container').appendChild(instructions);
            
            // Auto-hide instructions after 10 seconds
            setTimeout(() => {
                instructions.style.opacity = '0.3';
                instructions.addEventListener('mouseenter', () => {
                    instructions.style.opacity = '1';
                });
                instructions.addEventListener('mouseleave', () => {
                    instructions.style.opacity = '0.3';
                });
            }, 10000);
        });
    </script>
</body>
</html>